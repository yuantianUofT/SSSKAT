pert_results <- t(pert_results)
apply(pert_results, 2, var)
apply(r2[, 6:10], 2, var)
sim = 1
# perturbation function
pert_func <- function(nn, est_para, est_scoreM, est_invI, Y, X, S, Z, id.t, G) {
# perturbation weight
w <- 4*rbeta(nn, shape1 = 0.5, shape2 = 1.5)-1
# perturb parameter estimation
pert_est_para <- est_para + colMeans(w * est_scoreM) %*% (est_invI*nn)
pert_est_theta <- c(pert_est_para[1], pert_est_para[2], pert_est_para[4], log(sqrt(pert_est_para[3])), log(sqrt(pert_est_para[5])))
# perturb score estimation
pert_cvalue_est <- c_func(Y, X, S, Z, id.t, theta=pert_est_theta)
pert_est_indi_scores <- G * pert_cvalue_est * (1+w)
pert_result <- sum(pert_est_indi_scores)
return(pert_result)
}
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- as.vector(pert_results)
pert_var <- var(pert_results)
pert_var
# perturbation function
pert_func <- function(nn, est_para, est_scoreM, est_invI, Y, X, S, Z, id.t, G) {
# perturbation weight
w <- 4*rbeta(nn, shape1 = 0.5, shape2 = 1.5)-1
# perturb parameter estimation
pert_est_para <- est_para + colMeans(w * est_scoreM) %*% (est_invI*nn)
pert_est_theta <- c(pert_est_para[1], pert_est_para[2], pert_est_para[4], log(sqrt(pert_est_para[3])), log(sqrt(pert_est_para[5])))
return(pert_est_theta)
}
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- t(pert_results)
apply(pert_results, 2, var)
apply(r2[, 6:10], 2, var)
as.vector(apply(r2[, 6:10], 2, var))
apply(pert_results, 2, var)
r2$est_scores[1]
sim = 5546
obj.list <- generate_data(sim, nn, prev, S_para, maf)
Y <- obj.list$Y
S <- obj.list$S
id.t <- obj.list$id.t
X <- obj.list$X
Z <- obj.list$Z
G <- obj.list$G
# estimate the parameters under the null
est_theta <- suppressWarnings(ssl_theta(n = nn, Y = Y, X = X, S = S, Z = Z, id.t = id.t,
full_eval = TRUE, NULL_nlog_like,
nit, perturbW = NULL)$final_est)
# estimate scores under the null
cvalue_est <- c_func(Y, X, S, Z, id.t, theta=est_theta)
est_indi_scores <- G * cvalue_est
est_scores <- sum(est_indi_scores)
# estimated parameter values
est_a1 = est_theta[1]
est_mu1 = est_theta[2]
est_var1 = exp(est_theta[4])^2
est_mu0 = est_theta[3]
est_var0 = exp(est_theta[5])^2
est_para <- c(est_a1 = est_a1, est_mu1 = est_mu1, est_var1 = est_var1, est_mu0 = est_mu0, est_var0 = est_var0)
# Calculate scoreM
est_scoreM <- calculate_scoreM(var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S = S)
# Calculate inverse of the Fisher Information matrices
est_invI <- calculate_invI(var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S)
# perturbation variance construction
npert = 500
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- t(pert_results)
apply(pert_results, 2, var)
as.vector(apply(r2[, 6:10], 2, var))
apply(r2, 2, mean)
which(max(r2$pert_var))
which(r2$pert_var == max(r2$pert_var))
sim  = 3629
# generate data
obj.list <- generate_data(sim, nn, prev, S_para, maf)
Y <- obj.list$Y
S <- obj.list$S
id.t <- obj.list$id.t
X <- obj.list$X
Z <- obj.list$Z
G <- obj.list$G
table(Y[G == 1])
26/(110 + 26)
load("../results/SS_pert_tpara2_ACAT_maf0.001_prev0.2_150000_auc0.8.RData")
# clean results
simresult <- as.data.frame(simresult)
View(simresult)
# remove NA rows
simresult <- simresult[complete.cases(simresult), ]
# T1E table
T1E <- matrix(NA, 1, 2)
T1E[1, 1] <- length(which(simresult$pvalues_pert < 0.05)) / length(simresult$pvalues_pert)
T1E[1, 2] <- length(which(simresult$pvalue_b < 0.05)) / length(simresult$pvalue_b)
colnames(T1E) <- c("p_perturb", "p_oracle")
kable(T1E) %>%
kable_styling(full_width = F) %>%
row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid;") %>%
row_spec(1, extra_css = "border-bottom: 1px solid;")
ggplot() +
geom_histogram(aes(x = simresult$pert_var, fill = "Perturb"), alpha = 0.5, bins = 100) +
scale_fill_manual(values = c("Perturb" = "blue")) +
geom_vline(xintercept = var(simresult$t_scores), linetype = "dashed", color = "red") +
annotate("text", x = var(simresult$t_scores), y = 100, label = paste("Empirical variance:", round(var(simresult$est_scores), 4)), color = "red") +
labs(x = "Variance Estimation", fill = "Method") +
theme_minimal() +
theme(legend.position = "top")
var(simresult$t_scores)
load("../results/SS_pert_tpara2_ACAT_maf0.001_prev0.2_150000_auc0.8.RData")
# clean results
simresult <- as.data.frame(simresult)
# remove NA rows
simresult <- simresult[complete.cases(simresult), ]
# T1E table
T1E <- matrix(NA, 1, 2)
T1E[1, 1] <- length(which(simresult$pvalues_pert < 0.05)) / length(simresult$pvalues_pert)
T1E[1, 2] <- length(which(simresult$pvalue_b < 0.05)) / length(simresult$pvalue_b)
colnames(T1E) <- c("p_perturb", "p_oracle")
kable(T1E) %>%
kable_styling(full_width = F) %>%
row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid;") %>%
row_spec(1, extra_css = "border-bottom: 1px solid;")
load("../results/SS_pert_para_ACAT_maf0.5_prev0.5_150000_auc0.8.RData")
# clean results
simresult <- as.data.frame(simresult)
# remove NA rows
simresult <- simresult[complete.cases(simresult), ]
# T1E table
T1E <- matrix(NA, 1, 2)
T1E[1, 1] <- length(which(simresult$pvalues_pert < 0.05)) / length(simresult$pvalues_pert)
T1E[1, 2] <- length(which(simresult$pvalue_b < 0.05)) / length(simresult$pvalue_b)
colnames(T1E) <- c("p_perturb", "p_oracle")
kable(T1E) %>%
kable_styling(full_width = F) %>%
row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid;") %>%
row_spec(1, extra_css = "border-bottom: 1px solid;")
mean(simresult$pert_var)
remove.packages("SSSKAT")
install_github("yuantianUofT/SSSKAT")
remotes::install_github("yuantianUofT/SSSKAT")
library(MASS)
library(mvtnorm)
library(dplyr)
library(psych)
library(expm)
library(foreach)
library(doParallel)
library(SKAT)
library(ACAT)
library(SSSKAT)
setwd("~/Documents/GitHub/SS-simulation")
source("simulation scripts/gendata.R")
source("simulation scripts/helper_datagen.R")
source("~/Documents/GitHub/SSSKAT/R/SS_test.R", echo=TRUE)
ncores = detectCores() #Sys.getenv("SLURM_CPUS_PER_TASK")
registerDoParallel(cores=ncores)# Shows the number of Parallel Workers to be used
print(ncores) # this how many cores are available, and how many you have requested.
getDoParWorkers()#
# maf 0.1% to 1%
maf0 <- readRDS("simulation scripts/maf0.rds")
maf1 <- readRDS("simulation scripts/maf1.rds")
ntotal = 150000
nlabel_value = 100
prev_value = 0.2
nsnps = 20
distri = "normal"
dat <- gendata(nn = ntotal, prev=0.2, pve_age=0.1, pve_pcs=0.2, pve_sex = 0.03, prop_causal = 0.25, snps = 100,
label.size=nlabel_value, type="T1E",
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = NULL,
maf0, maf1,
S_type = "normal", S_para = c(m1 = 1, m0 = 0, s1 = 1, s0 = 0.5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = dat$G
id.t = dat$id.t
# Parameter estimation under the null
theta_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z, id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit)
# variance preparation, in real data this part only need to be done once for all genes as long as all elements in obj_SS remain the same
nboot = 5 # change to 500 in real data
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
para_func(nn = ntotal, theta = theta_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t)
}
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t, wBurden = rep(1, 20), wSKAT = rep(1, 20), wACAT = rep(1, 20),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
G = as.matrix(dat$G)
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t, wBurden = rep(1, 20), wSKAT = rep(1, 20), wACAT = rep(1, 20),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
dim(W)
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
dim(W)
nsnps
nsnps = 100
nsnps = 100
dat <- gendata(nn = ntotal, prev=0.2, pve_age=0.1, pve_pcs=0.2, pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type="T1E",
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = NULL,
maf0, maf1,
S_type = "normal", S_para = c(m1 = 1, m0 = 0, s1 = 1, s0 = 0.5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
# Parameter estimation under the null
theta_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z, id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit)
# variance preparation, in real data this part only need to be done once for all genes as long as all elements in obj_SS remain the same
nboot = 5 # change to 500 in real data
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
para_func(nn = ntotal, theta = theta_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t)
}
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
SS_result$Scovs
Y = Y; para_results = para_results; X = X; G = G; S = S; id.t = id.t; wBurden = rep(1, nsnps); wSKAT = rep(1, nsnps); wACAT = rep(1, nsnps);
weights.beta = NULL; mac.thresh = 10;
full_NR_evaluation = TRUE; nit = NULL; NULL_nlog_like;
testtype = "all"; boot = T
if (! testtype %in% c("all", "SKAT", "Burden", "ACAT")) {
stop("testtype is not correctly specified")
}
# data preparation
Z <- data.matrix(cbind(1, X))
if (testtype %in% c("all", "ACAT")) {
is.very.rare <- rare_func(G, mac.thresh)
}
Y = Y; para_results = para_results; X = X; G = G; S = S; id.t = id.t; wBurden = rep(1, nsnps); wSKAT = rep(1, nsnps); wACAT = rep(1, nsnps);
weights.beta = NULL; mac.thresh = 10;
full_NR_evaluation = TRUE; nit = NULL; NULL_nlog_like;
testtype = "all"; boot = T
if (! testtype %in% c("all", "SKAT", "Burden", "ACAT")) {
stop("testtype is not correctly specified")
}
# data preparation
Z <- data.matrix(cbind(1, X))
if (testtype %in% c("all", "ACAT")) {
is.very.rare <- rare_func(G, mac.thresh)
}
# cvalue estimates
cvalue <- c_func(Y, X, S, Z, id.t, theta = theta_est)
theta_est
theta = theta_est
# parameters setup
alpha <- theta[1:(ncol(X)+1)]
m1 <- theta[(ncol(X)+2)]
m0 <- theta[(ncol(X)+3)]
s1 <- exp(theta[(ncol(X)+4)])
theta_est = theta_est$final_est
# cvalue estimates
cvalue <- c_func(Y, X, S, Z, id.t, theta = theta_est)
# weights
if (is.null(wBurden) & is.null(wSKAT) & is.null(wACAT)) {
wBurden <- SKATBurdenW_func(G, weights.beta)
wSKAT <- wBurden
wACAT <- ACATW_func(G, is.very.rare, wBurden, weights.beta)
} else if ((!is.null(wBurden)) & is.null(wSKAT) & is.null(wACAT)) {
wSKAT <- wBurden
wACAT <- ACATW_func(G, is.very.rare, wBurden, weights.beta)
} else if (is.null(wBurden) & (!is.null(wSKAT)) & is.null(wACAT)) {
wBurden <- wSKAT
wACAT <- ACATW_func(G, is.very.rare, wBurden, weights.beta)
} else if (is.null(wBurden) & is.null(wSKAT) & (!is.null(wACAT))) {
wBurden <- SKATBurdenW_func(G, weights.beta)
wSKAT <- wBurden
} else if (is.null(wBurden) & (!is.null(wSKAT)) & (!is.null(wACAT))) {
wBurden <- wSKAT
} else if ((!is.null(wBurden)) & is.null(wSKAT) & (!is.null(wACAT))) {
wSKAT <- wBurden
} else if ((!is.null(wBurden)) & (!is.null(wSKAT)) & is.null(wACAT)) {
wACAT <- ACATW_func(G, is.very.rare, wBurden, weights.beta)
}
# scores
SKATscore <- SKATQ_fun(G, cvalue, wSKAT)
Burdenscore <- BurdenQ_fun(G, cvalue, wBurden)
ACATscore <- ACATsingleQ_fun(G, cvalue)
scoreQ <- list(SKATscoreQ = SKATscore$Q, BurdenscoreQ = Burdenscore$Q, ACATscoreQs = ACATscore$Q)
scoreQ
Scovs <- Var_boot(G, para_cvalue = para_results, is.very.rare, mac.thresh, wBurden, wSKAT, type=testtype)
SKAT_Scov <- Scovs$SKATSvar
Burden_Scov <- Scovs$BurdenSvar
ACAT_Scov <- Scovs$ACATSvar
ACAT_Scov
para_cvalue = para_results
type=testtype
# prepare dat
n <- nrow(G)
W <- diag(wSKAT)
GW <- G %*% W
Gw <- G %*% wBurden
ACATSvar <- ACATSVar_fun(G, para_cvalue, is.very.rare, mac.thresh, wBurden)
ACATSvar
(sum(!is.very.rare) == 0)
(sum(is.very.rare) == 0)
ACAT_vars <- ACATSsingleVar_fun(G, para_cvalue)
ACAT_vars
# apply ACATSsingleVar_fun across columns of G
ACAT_vars <- apply(G, 2, function(x) ACATSsingleVar_fun(x, para_cvalue)
ACAT_vars <- ACATSsingleVar_fun(G, para_cvalue)
# apply ACATSsingleVar_fun across columns of G
ACAT_vars <- apply(G, 2, function(x) ACATSsingleVar_fun(x, para_cvalue))
ACAT_vars
ACATSVar_fun <- function(G, para_cvalue, is.very.rare, mac.thresh, wBurden) {
if (sum(!is.very.rare) == 0) {
Burden_var <- BurdenSVar_fun(G, para_cvalue, wBurden)
S_vars <- Burden_var
} else if (sum(is.very.rare) == 0) {
# apply ACATSsingleVar_fun across columns of G
ACAT_vars <- apply(G, 2, function(x) ACATSsingleVar_fun(x, para_cvalue))
S_vars <- ACAT_vars
} else {
rareG <- G[, is.very.rare, drop = FALSE]
denseG <- G[, (!is.very.rare), drop = FALSE]
wrare <- wBurden[is.very.rare]
Burden_var <- BurdenSVar_fun(rareG, para_cvalue, wrare)
ACAT_vars <- apply(denseG, 2, function(x) ACATSsingleVar_fun(x, para_cvalue))
S_vars <- c(Burden_var, ACAT_vars)
}
return(S_vars)
}
Var_boot <- function(G, para_cvalue, is.very.rare, mac.thresh, wBurden, wSKAT, type) {
# prepare dat
n <- nrow(G)
W <- diag(wSKAT)
GW <- G %*% W
Gw <- G %*% wBurden
if (type == "ACAT") {
ACATSvar <- ACATSVar_fun(G, para_cvalue, is.very.rare, mac.thresh, wBurden)
Svar <- list(ACATSvar = ACATSvar)
} else if (type == "SKAT") {
SKATSvar <- SKATSVar_fun(G, para_cvalue, wSKAT)
Svar <- list(SKATSvar = SKATSvar)
} else if (type == "Burden") {
BurdenSvar <- BurdenSVar_fun(G, para_cvalue, wBurden)
Svar <- list(BurdenSvar = BurdenSvar)
} else {
ACATSvar <- ACATSVar_fun(G, para_cvalue, is.very.rare, mac.thresh, wBurden)
SKATSvar <- SKATSVar_fun(G, para_cvalue, wSKAT)
BurdenSvar <- BurdenSVar_fun(G, para_cvalue, wBurden)
Svar <- list(ACATSvar = ACATSvar, SKATSvar = SKATSvar, BurdenSvar = BurdenSvar)
}
return(Svar)
}
source("~/Documents/GitHub/SSSKAT/R/helper.R", echo=TRUE)
# Parameter estimation under the null
para_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z, id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit)
## results
SS_result <- SS_test(Y = Y, para_results = para_results, theta_est = para_est$final_est, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
source("~/Documents/GitHub/SSSKAT/R/SS_test.R", echo=TRUE)
## results
SS_result <- SS_test(Y = Y, para_results = para_results, theta_est = para_est$final_est, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
SS_result
source("~/Documents/GitHub/SS-simulation/simulation scripts/SS_test.R", echo=TRUE)
## results
SS_result <- SS_test(Y = Y, para_results = para_results, theta_est = para_est$final_est, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
SS_result$ACATpvaluesall
round(SS_result$ACATpvaluesall, 4)
min(SS_result$ACATpvaluesall)
which(SS_result$ACATpvaluesall == min(SS_result$ACATpvaluesall))
SS_result$Scovs$ACATSvar[44]
nboot = 50
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
para_func(nn = ntotal, theta = theta_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t)
}
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
para_func(nn = ntotal, theta = theta_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t)
}
nboot = 50
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
para_func(nn = ntotal, theta = para_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t)
}
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
## results
SS_result <- SS_test(Y = Y, para_results = para_results, theta_est = para_est$final_est, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
SS_result$ACATpvalues
min(SS_result$ACATpvalues)
which(SS_result$ACATpvaluesall == min(SS_result$ACATpvaluesall))
SS_result$Scovs$ACATSvar[21]
SS_result$pvalue
remove.packages("SSSKAT")
remotes::install_github("yuantianUofT/SSSKAT")
library(MASS)
library(mvtnorm)
library(dplyr)
library(psych)
library(expm)
library(foreach)
library(doParallel)
library(SKAT)
library(ACAT)
library(SSSKAT)
setwd("~/Documents/GitHub/SS-simulation")
source("simulation scripts/gendata.R")
source("simulation scripts/helper_datagen.R")
ncores = detectCores() #Sys.getenv("SLURM_CPUS_PER_TASK")
registerDoParallel(cores=ncores)# Shows the number of Parallel Workers to be used
print(ncores) # this how many cores are available, and how many you have requested.
getDoParWorkers()#
# maf 0.1% to 1%
maf0 <- readRDS("maf0.rds")
maf1 <- readRDS("maf1.rds")
ntotal = 150000
# maf 0.1% to 1%
maf0 <- readRDS("simulation scripts/maf0.rds")
maf1 <- readRDS("simulation scripts/maf1.rds")
ntotal = 150000
nlabel_value = 200
prev_value = 0.2
nsnps = 100
distri = "normal"
type_value = "T1E"
time1 <- proc.time()
nsim = 15
simresult <- vector("list", nsim)
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2, pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = NULL,
maf0, maf1,
S_type = distri, S_para = c(m1 = 1, m0 = 0, s1 = 1, s0 = 0.5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = dat$G
G = as.matrix(dat$G)
id.t = dat$id.t
# Parameter estimation under the null
para_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z, id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit)
# variance preparation, in real data this part only need to be done once for all genes as long as all elements in obj_SS remain the same
nboot = 5 # change to 500 in real data
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
para_func(nn = ntotal, theta = para_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t)
}
## results
SS_result <- SS_test(Y = Y, para_results = para_results, theta_est = para_est$final_est, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
setwd("/Users/tianyuan/Documents/GitHub/SSSKAT")
roxygen2::roxygenise()
remove.packages("SSSKAT")
