remove.packages("SSSKAT")
devtools::install_github("yuantianUofT/SSSKAT")
setwd("/Users/tianyuan/Documents/GitHub/SS-simulation/simulation scripts")
source("helper_datagen.R")
source("SS_test.R")
ncores = detectCores() #Sys.getenv("SLURM_CPUS_PER_TASK")
cl <- makeCluster(ncores)
registerDoParallel(cl)
print(ncores) # this how many cores are available, and how many you have requested.
getDoParWorkers()#
# maf 0.1% to 1%
maf <- readRDS("maf0.rds")  # maf1 <- readRDS("maf1.rds")
ntotal = 150000
nlabel_value = 2000
prev_value = 0.2
nsnps = 20
distri = "normal"
type_value = "T1E"
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2, pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 1, m0 = 0, s1 = 1, s0 = 0.5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
# Parameter estimation under the null
para_est <- SSSKAT::ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
para_est
nboot = 5
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
SSSKAT::para_func(nn = ntotal, theta = para_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t, distri = distri)
}
View(para_results)
nboot
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T, theta = para_est$final_est, distri = distri)
source("~/Documents/GitHub/SSSKAT/R/SS_test.R", echo=TRUE)
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T, theta = para_est$final_est, distri = distri)
## results
SS_result <- SSSKAT::SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T, theta = para_est$final_est, distri = distri)
SS_result
g.logit
g.logit(1)
g.logit(0)
nboot = 50
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
SSSKAT::para_func(nn = ntotal, theta = para_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t, distri = distri)
}
## results
SS_result <- SSSKAT::SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T, theta = para_est$final_est, distri = distri)
SS_result$pvalue
## Native
naive_result <- naive_test(X = X, G = G, S = S, id.t = id.t, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
mac.thresh = 10, testtype = "all")
# thresholded
thre_value <- get_Y_threshold(S, prev_value = mean(Y[id.t]))
thresholded_result <- threshold_test(Y = Y, X = X, G = G, S = S, id.t = id.t, thre_value = thre_value, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
mac.thresh = 10, testtype = "all")
# oracle
oracle_result <- labeled_test(Y = Y, X = X, G = G, id.t = id.t, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
mac.thresh = 10, testtype = "all")
# labeled
labeled_result <- suppressWarnings(tryCatch({
labeled_test(Y = Y, X = X, G = G, id.t = id.t, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
mac.thresh = 10, testtype = "all")
}, error = function(e) {
return(NA)
}))
final_results <- list(SS_result = SS_result,
naive_result = naive_result,
thresholded_result = thresholded_result,
oracle_result = oracle_result,
labeled_result = labeled_result)
final_results
###########################################################
#    Run STAARpipeline
###########################################################
rm(list=ls())
gc()
options(digits=22)
### load required package
# 1) uncomment the following if any packages used below is not installed
# library(devtools)
# install.packages("BiocManager")
# BiocManager::install("gdsfmt")
# BiocManager::install("SeqArray")
# BiocManager::install("SeqVarTools")
# BiocManager::install("GENESIS")
# install_github("xihaoli/STAAR")
# install_github("xihaoli/MultiSTAAR")
# install_github("zilinli1988/SCANG")
# BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
# install_github("xihaoli/STAARpipeline")
# install_github("xihaoli/STAARpipelineSummary")
# install.packages("psych")
# install.packages("expm")
# install.packages("doParallel")
# install.packages("caret")
# 2) load libraries
library(gdsfmt)
library(SeqArray)
library(SeqVarTools)
library(STAAR)
library(STAARpipeline)
library(STAARpipelineSummary)
library(dplyr)
library(psych)
library(expm)
library(foreach)
library(doParallel)
library(SKAT)
library(ACAT)
library(SSSKAT)
library(EnvStats)
# set up parallel computing, if use parallel computing uncomment the following:
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
print(ncores)
getDoParWorkers()
### load source functions
# TODO: change the following to the correct path
setwd('~/Documents/GitHub/SS-SKAT-Analysis')
set.seed(1)
GWAS_data <- readRDS("Ablation analysis example data/GWAS_data_with_S.rds") # TODO: change to the correct input path
GWAS_data <- as.data.frame(GWAS_data)
gds.path <- "/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao//1kGP_high_coverage_Illumina.chr1.filtered.SNV_INDEL_SV_phased_panel.gds"
# (File above available for download at: https://drive.google.com/drive/folders/19rSIkYrQz-2FKX0yJA5BSzLPD9ixKgq_?usp=share_link)
genofile <- seqOpen(gds.path)
Annotation_dir <- "annotation/info/FunctionalAnnotation"
Annotation_name_catalog <- get(load("Ablation analysis example data/Annotation_name_catalog.Rdata")) # TODO: change to the correct input path
total_n <- nrow(GWAS_data)
ablation_n <- ceiling(c(0.02, 0.05, 0.1, 0.15, 0.2) * total_n)
ablation_results <- c()
set.seed(1)
# Create obj_SS
id.t <- sample(1:total_n, num_samps, replace = FALSE)
num_samps <- ablation_n[1]
# Create obj_SS
id.t <- sample(1:total_n, num_samps, replace = FALSE)
covar <- GWAS_data %>% dplyr::select(starts_with("X")) %>% as.matrix()
obj_SS <- list(patient.id=GWAS_data$patient.id, id.t=id.t, y=GWAS_data$Y, s=GWAS_data$S, covar=covar, Z = cbind(1, covar)) # Z here is covariate in GWAS + a columns of 1, it's different than the Z in RF training dataset
min(S = obj_SS$s)
max(S = obj_SS$s)
# Parameter estimation under the null
theta_est <- SSSKAT::ssl_theta(Y = obj_SS$y, X = obj_SS$covar, S = obj_SS$s, Z = obj_SS$Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri = "normal") # estimated theta based on Y, X, S, Z, id.t, weights, full_eval, NULL_nlog_like, nit
# Parameter estimation under the null
theta_est <- SSSKAT::ssl_theta(Y = obj_SS$y, X = obj_SS$covar, S = obj_SS$s, Z = obj_SS$Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri = "beta") # estimated theta based on Y, X, S, Z, id.t, weights, full_eval, NULL_nlog_like, nit
obj_SS$theta_est <- theta_est$final_est # assigned estimated theta values to all patients
# Variance estimation bootstrap, in real data this part only need to be done once for all genes as long as all elements in obj_SS remain the same
nboot = 5 # change to 500 in real data
## loop version
para_results_list <- vector("list", nboot)
## loop version
para_results_list <- vector("list", nboot)
for (i in 1:nboot) {
para_results_list[[i]] <- para_func(nn = total_n, theta = obj_SS$theta_est, Y = obj_SS$y,
X = obj_SS$covar, S = obj_SS$s, Z = obj_SS$Z, id.t = obj_SS$id.t, distri = "beta")
}
para_results <- do.call(cbind, para_results_list)
# Run plof_SS
plof_result <- plof_SS(chr = 1, gene_name = "BRCA1", genofile = genofile, obj_SS, genes,
QC_label="annotation/info/QC_label", variant_type="SNV", geno_missing_imputation="mean",
Annotation_dir="annotation/info/FunctionalAnnotation", Annotation_name_catalog,
Use_annotation_weights=F, Annotation_name=NULL,
rare_maf_cutoff = 0.01, rv_num_cutoff = 2, mac.thresh = 10,
boot = T, para_results = para_results, distri = "beta")
# Run plof_SS
plof_result <- SSSKAT::plof_SS(chr = 1, gene_name = "BRCA1", genofile = genofile, obj_SS, genes,
QC_label="annotation/info/QC_label", variant_type="SNV", geno_missing_imputation="mean",
Annotation_dir="annotation/info/FunctionalAnnotation", Annotation_name_catalog,
Use_annotation_weights=F, Annotation_name=NULL,
rare_maf_cutoff = 0.01, rv_num_cutoff = 2, mac.thresh = 10,
boot = T, para_results = para_results, distri = "beta")
setwd("/Users/tianyuan/Documents/GitHub/SSSKAT")
roxygen2::roxygenise()
remove.packages("SSSKAT")
devtools::install_github("yuantianUofT/SSSKAT")
library(SSSKAT)
# Run plof_SS
plof_result <- SSSKAT::plof_SS(chr = 1, gene_name = "BRCA1", genofile = genofile, obj_SS, genes,
QC_label="annotation/info/QC_label", variant_type="SNV", geno_missing_imputation="mean",
Annotation_dir="annotation/info/FunctionalAnnotation", Annotation_name_catalog,
Use_annotation_weights=F, Annotation_name=NULL,
rare_maf_cutoff = 0.01, rv_num_cutoff = 2, mac.thresh = 10,
boot = T, para_results = para_results, distri = "beta")
warnings()
plof_result
total_n <- nrow(GWAS_data)
ablation_n <- ceiling(c(0.02, 0.05, 0.1, 0.15, 0.2) * total_n)
ablation_results <- c()
for(num_samps in ablation_n){
set.seed(1)
# Create obj_SS
id.t <- sample(1:total_n, num_samps, replace = FALSE)
covar <- GWAS_data %>% dplyr::select(starts_with("X")) %>% as.matrix()
obj_SS <- list(patient.id=GWAS_data$patient.id, id.t=id.t, y=GWAS_data$Y, s=GWAS_data$S, covar=covar, Z = cbind(1, covar)) # Z here is covariate in GWAS + a columns of 1, it's different than the Z in RF training dataset
# Parameter estimation under the null
theta_est <- SSSKAT::ssl_theta(Y = obj_SS$y, X = obj_SS$covar, S = obj_SS$s, Z = obj_SS$Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri = "beta") # estimated theta based on Y, X, S, Z, id.t, weights, full_eval, NULL_nlog_like, nit, use "beta" if S is predicted probability
obj_SS$theta_est <- theta_est$final_est # assigned estimated theta values to all patients
# Variance estimation bootstrap, in real data this part only need to be done once for all genes as long as all elements in obj_SS remain the same
nboot = 5 # change to 500 in real data
## parallel version
# para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
#   para_func(nn = total_n, theta = obj_SS$theta_est, Y = obj_SS$y,
#             X = obj_SS$covar, S = obj_SS$s, Z = obj_SS$Z, id.t = obj_SS$id.t)
# }
## loop version
para_results_list <- vector("list", nboot)
for (i in 1:nboot) {
para_results_list[[i]] <- para_func(nn = total_n, theta = obj_SS$theta_est, Y = obj_SS$y,
X = obj_SS$covar, S = obj_SS$s, Z = obj_SS$Z, id.t = obj_SS$id.t, distri = "beta")
}
para_results <- do.call(cbind, para_results_list)
# Run plof_SS
plof_result <- SSSKAT::plof_SS(chr = 1, gene_name = "BRCA1", genofile = genofile, obj_SS, genes,
QC_label="annotation/info/QC_label", variant_type="SNV", geno_missing_imputation="mean",
Annotation_dir="annotation/info/FunctionalAnnotation", Annotation_name_catalog,
Use_annotation_weights=F, Annotation_name=NULL,
rare_maf_cutoff = 0.01, rv_num_cutoff = 2, mac.thresh = 10,
boot = T, para_results = para_results, distri = "beta")
ablation_results <- rbind(ablation_results, plof_result$results) # add ablation size to the final output
}
ablation_results <- cbind(ablation_n, ablation_results)
View(ablation_results)
library(MASS)
library(mvtnorm)
library(dplyr)
library(psych)
library(expm)
library(foreach)
library(doParallel)
library(SKAT)
library(ACAT)
library(SSSKAT)
setwd("/Users/tianyuan/Documents/GitHub/SS-simulation/simulation scripts")
# setwd("/Users/tianyuan/Documents/GitHub/SS-simulation/simulation scripts")
source("gendata.R")
source("helper_datagen.R")
source("SS_test.R")
# maf 0.1% to 1%
maf <- readRDS("maf0.rds")  # maf1 <- readRDS("maf1.rds")
ncores = detectCores() #Sys.getenv("SLURM_CPUS_PER_TASK")
cl <- makeCluster(ncores)
registerDoParallel(cl)
print(ncores) # this how many cores are available, and how many you have requested.
getDoParWorkers()#
# maf 0.1% to 1%
maf <- readRDS("maf0.rds")  # maf1 <- readRDS("maf1.rds")
ntotal = 150000
nlabel_value = 2000
prev_value = 0.2
nsnps = 20
distri = "normal"
type_value = "T1E"
nsim = 10
nboot = 500
simresult <- vector("list", nsim)
distri = "beta"
type_value = "T1E"
(distri == "normal")
(distri == "beta")
if (distri == "normal") {
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2,
pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 1, m0 = 0, s1 = 1, s0 = 0.5))
} else if (distri == "beta") {
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2,
pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 5, m0 = 2, s1 = 5, s0 = 2))
}
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
min(S)
max(S)
# Parameter estimation under the null
para_est <- SSSKAT::ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
nboot = 50
Y = Y; X = X; S = S; Z = Z;
id.t = id.t; weights = NULL; full_eval = TRUE; NULL_nlog_like; nit; distri = distri
# initial estimates of the parameters
init_sl = sl_theta(Y, S, X, id.t, weights = NULL, distri)
init_sl
optim(par=init_sl, fn=NULL_nlog_like, Y = Y, X = X, S = S, Z = Z, id.t=id.t, distri=distri,
method="Nelder-Mead")
warnings()
exp(1.49221773736691298850587)
exp(0.69811839649238427440991)
cor(Y, S)
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2,
pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 10, m0 = 2, s1 = 10, s0 = 2))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
min(S)
max(S)
cor(Y, S)
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2,
pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 10, m0 = 5, s1 = 10, s0 = 5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
min(S)
max(S)
cor(Y, S)
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
min(S)
max(S)
cor(Y, S)
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2,
pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 2, m0 = 5, s1 = 10, s0 = 5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
min(S)
max(S)
cor(Y, S)
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2,
pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 5, m0 = 2, s1 = 5, s0 = 10))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
min(S)
max(S)
cor(Y, S)
pROC::roc(Y, S)
# Parameter estimation under the null
para_est <- SSSKAT::ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
para_est$final_est
exp(para_est$final_est)
# initial estimates of the parameters
init_sl = sl_theta(Y, S, X, id.t, weights = NULL, distri)
init_sl
exp(init_sl)
source("~/Documents/GitHub/SSSKAT/R/helper.R", echo=TRUE)
# initial estimates of the parameters
init_sl = sl_theta(Y, S, X, id.t, weights = NULL, distri)
init_sl
exp(init_sl)
optim(par=init_sl, fn=NULL_nlog_like, Y = Y, X = X, S = S, Z = Z, id.t=id.t, distri=distri,
method="Nelder-Mead")
exp(1.6028426599496212734408)
exp(0.7151432474293440977320)
exp(2.3312703590690113664152)
distri = "normal"
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2,
pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 1, m0 = -1, s1 = 1, s0 = 0.5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
min(S)
max(S)
cor(Y, S)
pROC::roc(Y, S)
# Parameter estimation under the null
para_est <- SSSKAT::ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
para_est$final_est
source("~/Documents/GitHub/SSSKAT/R/helper.R", echo=TRUE)
ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
exp(0.01278564001534399086069)
exp(-0.70196592257598655617556 )
para_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
theta = para_est$final_est
# parameters setup
alpha <- theta[1:(ncol(X)+1)]
m1 <- theta[(ncol(X)+2)]
s1 <- exp(theta[(ncol(X)+3)])
m0 <- theta[(ncol(X)+4)]
s0 <- exp(theta[(ncol(X)+5)])
m1
s1
m0
s0
distri = "beta"
if (distri == "normal") {
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2,
pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 1, m0 = -1, s1 = 1, s0 = 0.5))
} else if (distri == "beta") {
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2,
pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 5, m0 = 2, s1 = 5, s0 = 10))
}
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
min(S)
max(S)
cor(Y, S)
pROC::roc(Y, S)
# Parameter estimation under the null
para_est <- SSSKAT::ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
theta <- para_est$final_est
# parameters setup
alpha <- theta[1:(ncol(X)+1)]
m1 <- exp(theta[(ncol(X)+2)])
s1 <- exp(theta[(ncol(X)+3)])
m0 <- exp(theta[(ncol(X)+4)])
s0 <- exp(theta[(ncol(X)+5)])
m1
s1
m0
s0
roxygen2::roxygenise()
setwd("/Users/tianyuan/Documents/GitHub/SSSKAT")
roxygen2::roxygenise()
remove.packages("SSSKAT")
