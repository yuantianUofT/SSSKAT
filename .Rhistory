#   h_dvar1_mu0 <- D(D(logl_null, 'var1'), 'mu0')
#   h_dvar1_var0 <- D(D(logl_null, 'var1'), 'var0')
#   h_dmu0_2 <- D(D(logl_null, 'mu0'), 'mu0')
#   h_dmu0_var0 <- D(D(logl_null, 'mu0'), 'var0')
#   h_dvar0_2 <- D(D(logl_null, 'var0'), 'var0')
#
#
#   Hl_matrix <- vector("list", nn)
#
#   Hl_matrix <- lapply(1:nn, fill_matrix, var1 = var1, mu1 = mu1, var0 = var0, mu0 = mu0, a1 = a1, S = S,
#                      h_da1_2 = h_da1_2, h_da1_mu1 = h_da1_mu1, h_da1_var1 = h_da1_var1, h_da1_mu0 = h_da1_mu0,
#                      h_da1_var0 = h_da1_var0, h_dmu1_2 = h_dmu1_2, h_dmu1_var1 = h_dmu1_var1,
#                      h_dmu1_mu0 = h_dmu1_mu0, h_dmu1_var0 = h_dmu1_var0, h_dvar1_2 = h_dvar1_2,
#                      h_dvar1_mu0 = h_dvar1_mu0, h_dvar1_var0 = h_dvar1_var0, h_dmu0_2 = h_dmu0_2,
#                      h_dmu0_var0 = h_dmu0_var0, h_dvar0_2 = h_dvar0_2, est_scoreM = est_scoreM)
#
#   Hl_matrix <-  do.call(rbind, Hl_matrix)
#   return(Hl_matrix)
# }
# perturbation function
pert_func <- function(nn, est_para, est_scoreM, est_invI, Y, X, S, Z, id.t, G) {
# perturbation weight
w <- 4*rbeta(nn, shape1 = 0.5, shape2 = 1.5)-1
# perturb parameter estimation
pert_est_para <- est_para + colMeans(w * est_scoreM) %*% (est_invI*nn)
pert_est_theta <- c(pert_est_para[1], pert_est_para[2], pert_est_para[4], log(sqrt(pert_est_para[3])), log(sqrt(pert_est_para[5])))
# perturb score estimation
pert_cvalue_est <- c_func(Y, X, S, Z, id.t, theta=pert_est_theta)
pert_est_indi_scores <- G * pert_cvalue_est * (1+w)
pert_result <- sum(pert_est_indi_scores)
return(pert_result)
}
maf = 0.001
nn = 150000
prev = 0.2
sim = 5546
# generate data
obj.list <- generate_data(sim, nn, prev, S_para, maf)
Y <- obj.list$Y
S <- obj.list$S
id.t <- obj.list$id.t
X <- obj.list$X
Z <- obj.list$Z
G <- obj.list$G
# estimate the parameters under the null
est_theta <- suppressWarnings(ssl_theta(n = nn, Y = Y, X = X, S = S, Z = Z, id.t = id.t,
full_eval = TRUE, NULL_nlog_like,
nit, perturbW = NULL)$final_est)
est_theta
logit(0.2)
# estimate scores under the null
cvalue_est <- c_func(Y, X, S, Z, id.t, theta=est_theta)
est_indi_scores <- G * cvalue_est
est_scores <- sum(est_indi_scores)
est_indi_scores[G==1]
table(Y[G == 1])
12/(126+ 12)
# estimate scores under the null
cvalue_est <- c_func(Y, X, S, Z, id.t, theta=est_theta)
est_indi_scores <- G * cvalue_est
est_scores <- sum(est_indi_scores)
# estimated parameter values
est_a1 = est_theta[1]
est_mu1 = est_theta[2]
est_var1 = exp(est_theta[4])^2
est_mu0 = est_theta[3]
est_var0 = exp(est_theta[5])^2
est_para <- c(est_a1 = est_a1, est_mu1 = est_mu1, est_var1 = est_var1, est_mu0 = est_mu0, est_var0 = est_var0)
# Calculate scoreM
est_scoreM <- calculate_scoreM(var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S = S)
# Calculate inverse of the Fisher Information matrices
est_invI <- calculate_invI(var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S)
# est_invIls <- calculate_Iinvs(nn = nn, var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S = S, est_scoreM = est_scoreM)
# perturbation variance construction
npert = 500
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- as.vector(pert_results)
pert_var <- var(pert_results)
pert_var
# perturbation function
pert_func <- function(nn, est_para, est_scoreM, est_invI, Y, X, S, Z, id.t, G) {
# perturbation weight
w <- 4*rbeta(nn, shape1 = 0.5, shape2 = 1.5)-1
# perturb parameter estimation
pert_est_para <- est_para + colMeans(w * (est_scoreM ))  # %*% est_invI
pert_est_theta <- c(pert_est_para[1], pert_est_para[2], pert_est_para[4], log(sqrt(pert_est_para[3])), log(sqrt(pert_est_para[5])))
return(pert_est_theta)
}
# perturbation variance construction
npert = 500
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- as.vector(pert_results)
pert_results <- t(pert_results)
apply(pert_results, 2, var)
View(pert_results)
npert = 500
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- t(pert_results)
apply(pert_results, 2, var)
apply(r2[, 6:10], 2, var)
apply(r2[, 6:10], 2, var)
r2 <- r2[complete.cases(r2), ]
apply(r2[, 6:10], 2, var)
r2$pert_var[1]
r2$pert_var[2]
sim = 1
# generate data
obj.list <- generate_data(sim, nn, prev, S_para, maf)
Y <- obj.list$Y
S <- obj.list$S
id.t <- obj.list$id.t
X <- obj.list$X
Z <- obj.list$Z
G <- obj.list$G
# estimate the parameters under the null
est_theta <- suppressWarnings(ssl_theta(n = nn, Y = Y, X = X, S = S, Z = Z, id.t = id.t,
full_eval = TRUE, NULL_nlog_like,
nit, perturbW = NULL)$final_est)
# estimate scores under the null
cvalue_est <- c_func(Y, X, S, Z, id.t, theta=est_theta)
est_indi_scores <- G * cvalue_est
est_scores <- sum(est_indi_scores)
# estimated parameter values
est_a1 = est_theta[1]
est_mu1 = est_theta[2]
est_var1 = exp(est_theta[4])^2
est_mu0 = est_theta[3]
est_var0 = exp(est_theta[5])^2
est_para <- c(est_a1 = est_a1, est_mu1 = est_mu1, est_var1 = est_var1, est_mu0 = est_mu0, est_var0 = est_var0)
# Calculate scoreM
est_scoreM <- calculate_scoreM(var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S = S)
# Calculate inverse of the Fisher Information matrices
est_invI <- calculate_invI(var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S)
# est_invIls <- calculate_Iinvs(nn = nn, var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S = S, est_scoreM = est_scoreM)
# perturbation variance construction
npert = 500
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- t(pert_results)
apply(pert_results, 2, var)
# perturbation function
pert_func <- function(nn, est_para, est_scoreM, est_invI, Y, X, S, Z, id.t, G) {
# perturbation weight
w <- 4*rbeta(nn, shape1 = 0.5, shape2 = 1.5)-1
# perturb parameter estimation
pert_est_para <- est_para + colMeans(w * est_scoreM) %*% (est_invI*nn)
pert_est_theta <- c(pert_est_para[1], pert_est_para[2], pert_est_para[4], log(sqrt(pert_est_para[3])), log(sqrt(pert_est_para[5])))
return(pert_est_theta)
}
# perturbation variance construction
npert = 500
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- t(pert_results)
apply(pert_results, 2, var)
apply(r2[, 6:10], 2, var)
sim = 1
# perturbation function
pert_func <- function(nn, est_para, est_scoreM, est_invI, Y, X, S, Z, id.t, G) {
# perturbation weight
w <- 4*rbeta(nn, shape1 = 0.5, shape2 = 1.5)-1
# perturb parameter estimation
pert_est_para <- est_para + colMeans(w * est_scoreM) %*% (est_invI*nn)
pert_est_theta <- c(pert_est_para[1], pert_est_para[2], pert_est_para[4], log(sqrt(pert_est_para[3])), log(sqrt(pert_est_para[5])))
# perturb score estimation
pert_cvalue_est <- c_func(Y, X, S, Z, id.t, theta=pert_est_theta)
pert_est_indi_scores <- G * pert_cvalue_est * (1+w)
pert_result <- sum(pert_est_indi_scores)
return(pert_result)
}
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- as.vector(pert_results)
pert_var <- var(pert_results)
pert_var
# perturbation function
pert_func <- function(nn, est_para, est_scoreM, est_invI, Y, X, S, Z, id.t, G) {
# perturbation weight
w <- 4*rbeta(nn, shape1 = 0.5, shape2 = 1.5)-1
# perturb parameter estimation
pert_est_para <- est_para + colMeans(w * est_scoreM) %*% (est_invI*nn)
pert_est_theta <- c(pert_est_para[1], pert_est_para[2], pert_est_para[4], log(sqrt(pert_est_para[3])), log(sqrt(pert_est_para[5])))
return(pert_est_theta)
}
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- t(pert_results)
apply(pert_results, 2, var)
apply(r2[, 6:10], 2, var)
as.vector(apply(r2[, 6:10], 2, var))
apply(pert_results, 2, var)
r2$est_scores[1]
sim = 5546
obj.list <- generate_data(sim, nn, prev, S_para, maf)
Y <- obj.list$Y
S <- obj.list$S
id.t <- obj.list$id.t
X <- obj.list$X
Z <- obj.list$Z
G <- obj.list$G
# estimate the parameters under the null
est_theta <- suppressWarnings(ssl_theta(n = nn, Y = Y, X = X, S = S, Z = Z, id.t = id.t,
full_eval = TRUE, NULL_nlog_like,
nit, perturbW = NULL)$final_est)
# estimate scores under the null
cvalue_est <- c_func(Y, X, S, Z, id.t, theta=est_theta)
est_indi_scores <- G * cvalue_est
est_scores <- sum(est_indi_scores)
# estimated parameter values
est_a1 = est_theta[1]
est_mu1 = est_theta[2]
est_var1 = exp(est_theta[4])^2
est_mu0 = est_theta[3]
est_var0 = exp(est_theta[5])^2
est_para <- c(est_a1 = est_a1, est_mu1 = est_mu1, est_var1 = est_var1, est_mu0 = est_mu0, est_var0 = est_var0)
# Calculate scoreM
est_scoreM <- calculate_scoreM(var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S = S)
# Calculate inverse of the Fisher Information matrices
est_invI <- calculate_invI(var1 = est_var1, mu1 = est_mu1, var0 = est_var0, mu0 = est_mu0, a1 = est_a1, S)
# perturbation variance construction
npert = 500
pert_results <- sapply(1:npert, function(x) {
simseed <- npert * (sim - 1) + x
set.seed(simseed)
pert_func(nn = nn, est_para = est_para, est_scoreM = est_scoreM, est_invI = est_invI,
Y = Y, X = X, S = S, Z = Z, id.t = id.t, G = G)
})
pert_results <- t(pert_results)
apply(pert_results, 2, var)
as.vector(apply(r2[, 6:10], 2, var))
apply(r2, 2, mean)
which(max(r2$pert_var))
which(r2$pert_var == max(r2$pert_var))
sim  = 3629
# generate data
obj.list <- generate_data(sim, nn, prev, S_para, maf)
Y <- obj.list$Y
S <- obj.list$S
id.t <- obj.list$id.t
X <- obj.list$X
Z <- obj.list$Z
G <- obj.list$G
table(Y[G == 1])
26/(110 + 26)
load("../results/SS_pert_tpara2_ACAT_maf0.001_prev0.2_150000_auc0.8.RData")
# clean results
simresult <- as.data.frame(simresult)
View(simresult)
# remove NA rows
simresult <- simresult[complete.cases(simresult), ]
# T1E table
T1E <- matrix(NA, 1, 2)
T1E[1, 1] <- length(which(simresult$pvalues_pert < 0.05)) / length(simresult$pvalues_pert)
T1E[1, 2] <- length(which(simresult$pvalue_b < 0.05)) / length(simresult$pvalue_b)
colnames(T1E) <- c("p_perturb", "p_oracle")
kable(T1E) %>%
kable_styling(full_width = F) %>%
row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid;") %>%
row_spec(1, extra_css = "border-bottom: 1px solid;")
ggplot() +
geom_histogram(aes(x = simresult$pert_var, fill = "Perturb"), alpha = 0.5, bins = 100) +
scale_fill_manual(values = c("Perturb" = "blue")) +
geom_vline(xintercept = var(simresult$t_scores), linetype = "dashed", color = "red") +
annotate("text", x = var(simresult$t_scores), y = 100, label = paste("Empirical variance:", round(var(simresult$est_scores), 4)), color = "red") +
labs(x = "Variance Estimation", fill = "Method") +
theme_minimal() +
theme(legend.position = "top")
var(simresult$t_scores)
load("../results/SS_pert_tpara2_ACAT_maf0.001_prev0.2_150000_auc0.8.RData")
# clean results
simresult <- as.data.frame(simresult)
# remove NA rows
simresult <- simresult[complete.cases(simresult), ]
# T1E table
T1E <- matrix(NA, 1, 2)
T1E[1, 1] <- length(which(simresult$pvalues_pert < 0.05)) / length(simresult$pvalues_pert)
T1E[1, 2] <- length(which(simresult$pvalue_b < 0.05)) / length(simresult$pvalue_b)
colnames(T1E) <- c("p_perturb", "p_oracle")
kable(T1E) %>%
kable_styling(full_width = F) %>%
row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid;") %>%
row_spec(1, extra_css = "border-bottom: 1px solid;")
load("../results/SS_pert_para_ACAT_maf0.5_prev0.5_150000_auc0.8.RData")
# clean results
simresult <- as.data.frame(simresult)
# remove NA rows
simresult <- simresult[complete.cases(simresult), ]
# T1E table
T1E <- matrix(NA, 1, 2)
T1E[1, 1] <- length(which(simresult$pvalues_pert < 0.05)) / length(simresult$pvalues_pert)
T1E[1, 2] <- length(which(simresult$pvalue_b < 0.05)) / length(simresult$pvalue_b)
colnames(T1E) <- c("p_perturb", "p_oracle")
kable(T1E) %>%
kable_styling(full_width = F) %>%
row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid;") %>%
row_spec(1, extra_css = "border-bottom: 1px solid;")
mean(simresult$pert_var)
remotes::install_github("yuantianUofT/SSSKAT")
library(MASS)
library(mvtnorm)
library(dplyr)
library(psych)
library(expm)
library(foreach)
library(doParallel)
library(SKAT)
library(ACAT)
library(SSSKAT)
setwd("~/Documents/GitHub/SS-simulation")
source("simulation scripts/gendata.R")
source("simulation scripts/helper_datagen.R")
ncores = detectCores() #Sys.getenv("SLURM_CPUS_PER_TASK")
registerDoParallel(cores=ncores)# Shows the number of Parallel Workers to be used
print(ncores) # this how many cores are available, and how many you have requested.
getDoParWorkers()#
# maf0 <- runif(100, 0.001, 0.01)
# maf1 <- runif(100, 0.001, 0.01)
# saveRDS(maf0, "simulation scripts/maf0.rds")
# saveRDS(maf1, "simulation scripts/maf1.rds")
# maf 0.1% to 1%
maf0 <- readRDS("simulation scripts/maf0.rds")
maf1 <- readRDS("simulation scripts/maf1.rds")
ntotal = 150000
nlabel_value = 200
prev_value = 0.2
nsnps = 100
distri = "normal"
type_value = "T1E"
time1 <- proc.time()
nsim = 15
simresult <- vector("list", nsim)
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2, pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = NULL,
maf0, maf1,
S_type = distri, S_para = c(m1 = 1, m0 = 0, s1 = 1, s0 = 0.5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
# Parameter estimation under the null
para_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z, id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit)
# variance preparation, in real data this part only need to be done once for all genes as long as all elements in obj_SS remain the same
nboot = 5 # change to 500 in real data
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
para_func(nn = ntotal, theta = para_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t)
}
## results
SS_result <- SS_test(Y = Y, para_results = para_results, theta_est = para_est$final_est, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
SS_result$pvalue
source("SS_test.R")
source("simulation scripts/SS_test.R")
## results
SS_result <- SS_test(Y = Y, para_results = para_results, theta_est = para_est$final_est, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
SS_result$ACATpvalues
min(SS_result$ACATpvaluesall)
which(SS_result$ACATpvaluesall == min(SS_result$ACATpvaluesall))
SS_result$Scovs$ACATSvar[66]
source("~/Documents/GitHub/SSSKAT/R/SS_test.R", echo=TRUE)
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
SS_result
setwd("/Users/tianyuan/Documents/GitHub/SSSKAT/R")
setwd("/Users/tianyuan/Documents/GitHub/SSSKAT")
roxygen2::roxygenise()
remove.packages("SSSKAT")
remotes::install_github("yuantianUofT/SSSKAT")
library(MASS)
library(mvtnorm)
library(dplyr)
library(psych)
library(expm)
library(foreach)
library(doParallel)
library(SKAT)
library(ACAT)
library(SSSKAT)
setwd("~/Documents/GitHub/SS-simulation")
source("simulation scripts/gendata.R")
source("simulation scripts/helper_datagen.R")
source("simulation scripts/SS_test.R")
ncores = detectCores() #Sys.getenv("SLURM_CPUS_PER_TASK")
registerDoParallel(cores=ncores)# Shows the number of Parallel Workers to be used
print(ncores) # this how many cores are available, and how many you have requested.
getDoParWorkers()#
# maf 0.1% to 1%
maf0 <- readRDS("simulation scripts/maf0.rds")
maf1 <- readRDS("simulation scripts/maf1.rds")
ntotal = 150000
nlabel_value = 200
prev_value = 0.2
nsnps = 100
distri = "normal"
type_value = "T1E"
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2, pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = NULL,
maf0, maf1,
S_type = distri, S_para = c(m1 = 1, m0 = 0, s1 = 1, s0 = 0.5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
# Parameter estimation under the null
para_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z, id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit)
nboot = 5
para_results <- foreach(i = 1:nboot, .combine = cbind) %dopar% {
simseed <- i
set.seed(simseed)
para_func(nn = ntotal, theta = para_est$final_est, Y = Y,
X = X, S = S, Z = Z, id.t = id.t)
}
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
## Native
naive_result <- naive_test(X = X, G = G, S = S, id.t = id.t, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
mac.thresh = 10, testtype = "all")
# thresholded
thre_value <- get_Y_threshold(S, prev_value = mean(Y[id.t]))
thresholded_result <- threshold_test(Y = Y, X = X, G = G, S = S, id.t = id.t, thre_value = thre_value, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
mac.thresh = 10, testtype = "all")
# oracle
oracle_result <- labeled_test(Y = Y, X = X, G = G, id.t = id.t, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
mac.thresh = 10, testtype = "all")
# labeled
labeled_result <- suppressWarnings(tryCatch({
labeled_test(Y = Y, X = X, G = G, id.t = id.t, wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
mac.thresh = 10, testtype = "all")
}, error = function(e) {
return(NA)
}))
final_results <- list(SS_result = SS_result,
naive_result = naive_result,
thresholded_result = thresholded_result,
oracle_result = oracle_result,
labeled_result = labeled_result)
nsim = 15
simresult <- vector("list", nsim)
# append the final_results to simresult
simresult[[sim]] <- final_results
para_results
## results
SS_result <- SS_test(Y = Y, para_results = para_results, X = X, G = G, S = S, id.t = id.t,
wBurden = rep(1, nsnps), wSKAT = rep(1, nsnps), wACAT = rep(1, nsnps),
weights.beta = NULL, mac.thresh = 10,
full_NR_evaluation = TRUE, nit = NULL, NULL_nlog_like,
testtype = "all", boot = T)
devtools::install_github("yuantianUofT/SSSKAT")
remotes::install_github("yuantianUofT/SSSKAT")
remove.packages("SSSKAT")
remotes::install_github("yuantianUofT/SSSKAT")
library(SSSKAT)
SS_test
setwd("/Users/tianyuan/Documents/GitHub/SSSKAT/R")
setwd("/Users/tianyuan/Documents/GitHub/SSSKAT")
roxygen2::roxygenise()
