########################################################
S_normal <- function(nn, y, m1, m0, s1, s0) {
s = rep(NA, nn)
s[y == 1] <- rnorm(n = sum(y), mean = m1, sd = s1)
s[y == 0] <- rnorm(n = sum(1-y), mean = m0, sd = s0)
return(s)
}
alpha0 <- 0
alpha1 <- 0.5
m1=1; m0=0; s1=1; s0=0.5
set.seed(666)
# Generate two covariates
N <- length(phenotype.id)
sex <- pheno_cov$gender=="female"
PCs <- read.table("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/output.sparseGRM.score",header=FALSE)
colnames(PCs)[2:12] <- c("id","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")
# generate phenotype and surrogate
p <- SSSKAT::g.logit(alpha0 + alpha1 * sex + LDLR_Effect + APOE_Effect)
# generate phenotype and surrogate
p <- SSSKAT::g.logit(alpha0 + alpha1 * sex)
y <- sapply(1:length(p), function(index) rbinom(1, 1, p[index]))
s <- S_normal(nn = length(y), y, m1, m0, s1, s0) # ROC 0.8 of s on y
roc(y, s)
pheno <- cbind(pheno_cov, y, s)
pheno <- dplyr::left_join(pheno,PCs[,2:12],by=c("sample"="id"))
pROC::roc(y, s)
pheno <- cbind(pheno_cov, y, s)
pheno <- dplyr::left_join(pheno,PCs[,2:12],by=c("sample"="id"))
covar <- pheno[, c("PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")]
covar <- cbind(sex, covar)
covar$sex <- as.numeric(covar$sex)
###########################################################
#    Run STAARpipeline
#    Date: 20231105
###########################################################
rm(list=ls())
gc()
### load required package
library(gdsfmt)
library(SeqArray)
library(SeqVarTools)
library(STAAR)
library(STAARpipeline)
library(STAARpipelineSummary)
### load source functions
source("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/STAAR_SS.R")
source("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/SS_test.R")
source("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/helper.R")
source("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/plof_SS.R")
## phenotype.id
pheno_cov <- read.table("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/integrated_call_samples_v3.20130502.ALL.panel",header=TRUE)
phenotype.id <- as.vector(pheno_cov$sample)
########################################################
#       Simulated Binary Phenotype and continuous surrogate
########################################################
S_normal <- function(nn, y, m1, m0, s1, s0) {
s = rep(NA, nn)
s[y == 1] <- rnorm(n = sum(y), mean = m1, sd = s1)
s[y == 0] <- rnorm(n = sum(1-y), mean = m0, sd = s0)
return(s)
}
alpha0 <- 0
alpha1 <- 0.5
m1=1; m0=0; s1=1; s0=0.5
set.seed(666)
# Generate two covariates
N <- length(phenotype.id)
sex <- pheno_cov$gender=="female"
PCs <- read.table("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/output.sparseGRM.score",header=FALSE)
colnames(PCs)[2:12] <- c("id","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")
# generate phenotype and surrogate
p <- SSSKAT::g.logit(alpha0 + alpha1 * sex)
y <- sapply(1:length(p), function(index) rbinom(1, 1, p[index]))
s <- S_normal(nn = length(y), y, m1, m0, s1, s0) # ROC 0.8 of s on y
pROC::roc(y, s)
pheno <- cbind(pheno_cov, y, s)
pheno <- dplyr::left_join(pheno,PCs[,2:12],by=c("sample"="id"))
covar <- pheno[, c("PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")]
covar <- cbind(sex, covar)
covar$sex <- as.numeric(covar$sex)
# labeled data
id.t <- sample(1:length(s), 200)
obj_SS <- list(phenotype.id=phenotype.id, id.t=id.t, y=y, s=s, covar=covar)
dat_null <- cbind(y, covar, s)
colnames(dat_null) <- c("Y", paste0("X", 1:ncol(covar)), "S")
theta_est <- ssl_theta(dat = dat_null, id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit)
obj_SS$theta_est <- theta_est
obj_SS
obj_SS$theta_est <- theta_est$final_est
obj_SS
gds.path <- "/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/1kGP_high_coverage_Illumina.chr1.filtered.SNV_INDEL_SV_phased_panel.gds"
genofile <- seqOpen(gds.path)
gds.path <- "/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/1kGP_high_coverage_Illumina.chr1.filtered.SNV_INDEL_SV_phased_panel.gds"
genofile <- seqOpen(gds.path)
Annotation_dir <- "annotation/info/FunctionalAnnotation"
Annotation_name_catalog <- get(load("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/Annotation_name_catalog.Rdata"))
plof_result <- plof_SS(chr = 1, gene_name = "BRCA1", genofile = genofile, obj_SS, genes,
QC_label="annotation/info/QC_label", variant_type="SNV", geno_missing_imputation="mean",
Annotation_dir="annotation/info/FunctionalAnnotation", Annotation_name_catalog,
Use_annotation_weights=F, Annotation_name=NULL,
rare_maf_cutoff = 0.01, rv_num_cutoff = 2, mac.thresh = 10,
boot = T, nboot = 10000)
View(plof_result)
plof_result <- plof_SS(chr = 1, gene_name = "BRCA1", genofile = genofile, obj_SS, genes,
QC_label="annotation/info/QC_label", variant_type="SNV", geno_missing_imputation="mean",
Annotation_dir="annotation/info/FunctionalAnnotation", Annotation_name_catalog,
Use_annotation_weights=F, Annotation_name=NULL,
rare_maf_cutoff = 0.01, rv_num_cutoff = 2, mac.thresh = 20,
boot = T, nboot = 10000)
View(plof_result)
rm(list=ls())
gc()
### load required package
library(gdsfmt)
library(SeqArray)
library(SeqVarTools)
library(STAAR)
library(STAARpipeline)
library(STAARpipelineSummary)
### load source functions
source("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/STAAR_SS.R")
source("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/SS_test.R")
source("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/helper.R")
source("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/plof_SS.R")
## phenotype.id
pheno_cov <- read.table("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/integrated_call_samples_v3.20130502.ALL.panel",header=TRUE)
phenotype.id <- as.vector(pheno_cov$sample)
S_normal <- function(nn, y, m1, m0, s1, s0) {
s = rep(NA, nn)
s[y == 1] <- rnorm(n = sum(y), mean = m1, sd = s1)
s[y == 0] <- rnorm(n = sum(1-y), mean = m0, sd = s0)
return(s)
}
alpha0 <- 0
alpha1 <- 0.5
m1=1; m0=0; s1=1; s0=0.5
set.seed(666)
# Generate two covariates
N <- length(phenotype.id)
sex <- pheno_cov$gender=="female"
PCs <- read.table("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/output.sparseGRM.score",header=FALSE)
colnames(PCs)[2:12] <- c("id","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")
# generate phenotype and surrogate
p <- SSSKAT::g.logit(alpha0 + alpha1 * sex)
y <- sapply(1:length(p), function(index) rbinom(1, 1, p[index]))
s <- S_normal(nn = length(y), y, m1, m0, s1, s0) # ROC 0.8 of s on y
pROC::roc(y, s)
pheno <- cbind(pheno_cov, y, s)
pheno <- dplyr::left_join(pheno,PCs[,2:12],by=c("sample"="id"))
covar <- pheno[, c("PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")]
covar <- cbind(sex, covar)
covar$sex <- as.numeric(covar$sex)
# labeled data
id.t <- sample(1:length(s), 200)
obj_SS <- list(phenotype.id=phenotype.id, id.t=id.t, y=y, s=s, covar=covar)
dat_null <- cbind(y, covar, s)
colnames(dat_null) <- c("Y", paste0("X", 1:ncol(covar)), "S")
theta_est <- ssl_theta(dat = dat_null, id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit)
obj_SS$theta_est <- theta_est$final_est
gds.path <- "/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/1kGP_high_coverage_Illumina.chr1.filtered.SNV_INDEL_SV_phased_panel.gds"
genofile <- seqOpen(gds.path)
Annotation_dir <- "annotation/info/FunctionalAnnotation"
Annotation_name_catalog <- get(load("/Users/tianyuan/Desktop/UoT/SKAT 2023/Xihao/Annotation_name_catalog.Rdata"))
plof_result <- plof_SS(chr = 1, gene_name = "BRCA1", genofile = genofile, obj_SS, genes,
QC_label="annotation/info/QC_label", variant_type="SNV", geno_missing_imputation="mean",
Annotation_dir="annotation/info/FunctionalAnnotation", Annotation_name_catalog,
Use_annotation_weights=F, Annotation_name=NULL,
rare_maf_cutoff = 0.01, rv_num_cutoff = 2, mac.thresh = 10,
boot = T, nboot = 10)
plof_result
# supervised likelihood
logl_null=expression(y*log((1 / (1 + exp(-(a1))))) + (1-y)*log(1-(1 / (1 + exp(-(a1))))))
# first derivative
logl_null_a1 <- D(logl_null,'a1')
logl_null_a1
2870.820/60
remove.packages("SSSKAT")
source("~/Documents/GitHub/SS-SKAT-Analysis/Ablation analysis script/helper.R", echo=TRUE)
library(MASS)
library(mvtnorm)
library(dplyr)
library(psych)
library(expm)
library(foreach)
library(doParallel)
library(SKAT)
library(ACAT)
setwd("/Users/tianyuan/Documents/GitHub/SS-simulation/simulation scripts")
source("gendata.R")
source("helper_datagen.R")
# maf 0.1% to 1%
maf <- readRDS("maf0.rds")  # maf1 <- readRDS("maf1.rds")
ntotal = 150000
nlabel_value = 2000
prev_value = 0.2
nsnps = 20
distri = "normal"
type_value = "T1E"
time1 <- proc.time()
nsim = 10
nboot = 500
simresult <- vector("list", nsim)
dat <- gendata(nn = ntotal, prev = prev_value, pve_age = 0.1, pve_pcs = 0.2, pve_sex = 0.03, prop_causal = 0.25, snps = nsnps,
label.size=nlabel_value, type = type_value,
x_mean0 = c(0, 0.1, 0, 0, 0), x_mean1 = NULL, x_cov = diag(rep(1, 5)),
maf0 = maf[1:20], maf1 = maf[1:20],
S_type = distri, S_para = c(m1 = 1, m0 = 0, s1 = 1, s0 = 0.5))
# data preparation
Y = dat$y
X = dat$X
S = dat$s
Z = cbind(1, X)
G = as.matrix(dat$G)
id.t = dat$id.t
ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit)
source("~/Documents/GitHub/SSSKAT/R/helper.R", echo=TRUE)
# Parameter estimation under the null
para_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
# initial estimates of the parameters
init_sl = sl_theta(Y, S, X, id.t, weights = NULL, distri)
source("~/Documents/GitHub/SSSKAT/R/helper.R", echo=TRUE)
source("~/Documents/GitHub/SSSKAT/R/helper.R", echo=TRUE)
# Parameter estimation under the null
para_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
sl_theta(Y, S, X, id.t, weights = NULL, distri)
# prevalence estimate
if (length(id.t) != 0) {
prev_est = mean(Y[id.t])
}
# weights setup
if (is.null(weights)) {
weights = rep(1, length(id.t))
}
# separate labeled_id based on case/control status
id.1 = intersect(which(Y==1), id.t)
id.0 = intersect(which(Y==0), id.t)
# with some labeled data, under the null hypothesis, get supervised estimates
if (length(id.t) == 0) {
alpha=lm(S~X)$coef
} else{
alpha=glm(Y[id.t] ~ X[id.t, ],family=binomial(link = "logit"), weights = weights)$coef
}
# without labeled data, threshold S lower than 20% as labeled controls and greater than 80% as labeled cases
if (distri == "normal") {
if (length(id.t) == 0) {
thre_value1 <- quantile(S, 0.5)
m1= mean(S[which(S>thre_value1)])
s1= sd(S[which(S>thre_value1)])
m0=mean(S[S<thre_value1])
s0=sd(S[S<thre_value1])
} else{
result <- tryCatch({
m1= mean(S[id.1])
s1= sd(S[id.1])
m0=mean(S[id.0])
s0=sd(S[id.0])
list(m1 = m1, s1 = s1, m0 = m0, m1 = m1)
}, error = function(e) {
thre_value1 <- quantile(S, 0.5)
m1= mean(S[which(S>thre_value1)])
s1= sd(S[which(S>thre_value1)])
m0=mean(S[S<thre_value1])
s0=sd(S[S<thre_value1])
list(m1 = m1, s1 = s1, m0 = m0, m1 = m1)
})
m1 <- result$m1
s1 <- result$s1
m0 <- result$m0
s0 <- result$s0
}
} else {
if (length(id.t) == 0) {
id.1 <- which(S>0.5)
id.0 <- which(S<=0.5)
paras1 <- EnvStats::ebeta(S[id.1], method = "mle")
paras0 <- EnvStats::ebeta(S[id.0], method = "mle")
} else{
result <- tryCatch({
paras1 <- EnvStats::ebeta(S[id.1], method = "mle")
paras0 <- EnvStats::ebeta(S[id.0], method = "mle")
list(paras1 = paras1, paras0 = paras0)
}, error = function(e) {
id.1 <- which(S > 0.5)
id.0 <- which(S <= 0.5)
paras1 <- EnvStats::ebeta(S[id.1], method = "mle")
paras0 <- EnvStats::ebeta(S[id.0], method = "mle")
list(paras1 = paras1, paras0 = paras0)
})
paras1 <- result$paras1
paras0 <- result$paras0
}
m1 <- paras1$parameters[1]
s1 <- paras1$parameters[2]
m0 <- paras0$parameters[1]
s0 <- paras0$parameters[2]
}
weights = NULL
# weights setup
if (is.null(weights)) {
weights = rep(1, length(id.t))
}
# separate labeled_id based on case/control status
id.1 = intersect(which(Y==1), id.t)
id.0 = intersect(which(Y==0), id.t)
# with some labeled data, under the null hypothesis, get supervised estimates
if (length(id.t) == 0) {
alpha=lm(S~X)$coef
} else{
alpha=glm(Y[id.t] ~ X[id.t, ],family=binomial(link = "logit"), weights = weights)$coef
}
# without labeled data, threshold S lower than 20% as labeled controls and greater than 80% as labeled cases
if (distri == "normal") {
if (length(id.t) == 0) {
thre_value1 <- quantile(S, 0.5)
m1= mean(S[which(S>thre_value1)])
s1= sd(S[which(S>thre_value1)])
m0=mean(S[S<thre_value1])
s0=sd(S[S<thre_value1])
} else{
result <- tryCatch({
m1= mean(S[id.1])
s1= sd(S[id.1])
m0=mean(S[id.0])
s0=sd(S[id.0])
list(m1 = m1, s1 = s1, m0 = m0, m1 = m1)
}, error = function(e) {
thre_value1 <- quantile(S, 0.5)
m1= mean(S[which(S>thre_value1)])
s1= sd(S[which(S>thre_value1)])
m0=mean(S[S<thre_value1])
s0=sd(S[S<thre_value1])
list(m1 = m1, s1 = s1, m0 = m0, m1 = m1)
})
m1 <- result$m1
s1 <- result$s1
m0 <- result$m0
s0 <- result$s0
}
} else {
if (length(id.t) == 0) {
id.1 <- which(S>0.5)
id.0 <- which(S<=0.5)
paras1 <- EnvStats::ebeta(S[id.1], method = "mle")
paras0 <- EnvStats::ebeta(S[id.0], method = "mle")
} else{
result <- tryCatch({
paras1 <- EnvStats::ebeta(S[id.1], method = "mle")
paras0 <- EnvStats::ebeta(S[id.0], method = "mle")
list(paras1 = paras1, paras0 = paras0)
}, error = function(e) {
id.1 <- which(S > 0.5)
id.0 <- which(S <= 0.5)
paras1 <- EnvStats::ebeta(S[id.1], method = "mle")
paras0 <- EnvStats::ebeta(S[id.0], method = "mle")
list(paras1 = paras1, paras0 = paras0)
})
paras1 <- result$paras1
paras0 <- result$paras0
}
m1 <- paras1$parameters[1]
s1 <- paras1$parameters[2]
m0 <- paras0$parameters[1]
s0 <- paras0$parameters[2]
}
# initial estimates of the parameters
if (distri == "normal") {
init_est <- c(alpha = alpha, m1 = m1, logs1 = log(s1), m0 = m0, logs1 = log(s0))
} else {
init_est <- c(alpha = alpha, logm1 = log(m1), logs1 = log(s1), logm0 = log(m0), logs0 = log(s0))
}
s0
result <- tryCatch({
m1= mean(S[id.1])
s1= sd(S[id.1])
m0=mean(S[id.0])
s0=sd(S[id.0])
list(m1 = m1, s1 = s1, m0 = m0, m1 = m1)
}, error = function(e) {
thre_value1 <- quantile(S, 0.5)
m1= mean(S[which(S>thre_value1)])
s1= sd(S[which(S>thre_value1)])
m0=mean(S[S<thre_value1])
s0=sd(S[S<thre_value1])
list(m1 = m1, s1 = s1, m0 = m0, m1 = m1)
})
result
result <- tryCatch({
m1= mean(S[id.1])
s1= sd(S[id.1])
m0=mean(S[id.0])
s0=sd(S[id.0])
list(m1 = m1, s1 = s1, m0 = m0, s1 = s1)
}, error = function(e) {
thre_value1 <- quantile(S, 0.5)
m1= mean(S[which(S>thre_value1)])
s1= sd(S[which(S>thre_value1)])
m0=mean(S[S<thre_value1])
s0=sd(S[S<thre_value1])
list(m1 = m1, s1 = s1, m0 = m0, m1 = m1)
})
init_est <- c(alpha = alpha, m1 = m1, logs1 = log(s1), m0 = m0, logs1 = log(s0))
init_est
source("~/Documents/GitHub/SSSKAT/R/helper.R", echo=TRUE)
# Parameter estimation under the null
para_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
source("~/Documents/GitHub/SSSKAT/R/helper.R", echo=TRUE)
# initial estimates of the parameters
init_sl = sl_theta(Y, S, X, id.t, weights = NULL, distri)
# prevalence estimate
if (length(id.t) != 0) {
prev_est = mean(Y[id.t])
}
# weights setup
if (is.null(weights)) {
weights = rep(1, length(id.t))
}
# separate labeled_id based on case/control status
id.1 = intersect(which(Y==1), id.t)
id.0 = intersect(which(Y==0), id.t)
# with some labeled data, under the null hypothesis, get supervised estimates
if (length(id.t) == 0) {
alpha=lm(S~X)$coef
} else{
alpha=glm(Y[id.t] ~ X[id.t, ],family=binomial(link = "logit"), weights = weights)$coef
}
# without labeled data, threshold S lower than 20% as labeled controls and greater than 80% as labeled cases
if (distri == "normal") {
if (length(id.t) == 0) {
thre_value1 <- quantile(S, 0.5)
m1= mean(S[which(S>thre_value1)])
s1= sd(S[which(S>thre_value1)])
m0=mean(S[S<thre_value1])
s0=sd(S[S<thre_value1])
} else{
result <- tryCatch({
m1= mean(S[id.1])
s1= sd(S[id.1])
m0=mean(S[id.0])
s0=sd(S[id.0])
list(m1 = m1, s1 = s1, m0 = m0, s1 = s1)
}, error = function(e) {
thre_value1 <- quantile(S, 0.5)
m1= mean(S[which(S>thre_value1)])
s1= sd(S[which(S>thre_value1)])
m0=mean(S[S<thre_value1])
s0=sd(S[S<thre_value1])
list(m1 = m1, s1 = s1, m0 = m0, m1 = m1)
})
m1 <- result$m1
s1 <- result$s1
m0 <- result$m0
s0 <- result$s0
}
} else {
if (length(id.t) == 0) {
id.1 <- which(S>0.5)
id.0 <- which(S<=0.5)
paras1 <- EnvStats::ebeta(S[id.1], method = "mle")
paras0 <- EnvStats::ebeta(S[id.0], method = "mle")
} else{
result <- tryCatch({
paras1 <- EnvStats::ebeta(S[id.1], method = "mle")
paras0 <- EnvStats::ebeta(S[id.0], method = "mle")
list(paras1 = paras1, paras0 = paras0)
}, error = function(e) {
id.1 <- which(S > 0.5)
id.0 <- which(S <= 0.5)
paras1 <- EnvStats::ebeta(S[id.1], method = "mle")
paras0 <- EnvStats::ebeta(S[id.0], method = "mle")
list(paras1 = paras1, paras0 = paras0)
})
paras1 <- result$paras1
paras0 <- result$paras0
}
m1 <- paras1$parameters[1]
s1 <- paras1$parameters[2]
m0 <- paras0$parameters[1]
s0 <- paras0$parameters[2]
}
# initial estimates of the parameters
if (distri == "normal") {
init_est <- c(alpha = alpha, m1 = m1, logs1 = log(s1), m0 = m0, logs1 = log(s0))
} else {
init_est <- c(alpha = alpha, logm1 = log(m1), logs1 = log(s1), logm0 = log(m0), logs0 = log(s0))
}
s0
result <- tryCatch({
m1= mean(S[id.1])
s1= sd(S[id.1])
m0=mean(S[id.0])
s0=sd(S[id.0])
list(m1 = m1, s1 = s1, m0 = m0, s1 = s1)
}, error = function(e) {
thre_value1 <- quantile(S, 0.5)
m1= mean(S[which(S>thre_value1)])
s1= sd(S[which(S>thre_value1)])
m0=mean(S[S<thre_value1])
s0=sd(S[S<thre_value1])
list(m1 = m1, s1 = s1, m0 = m0, m1 = m1)
})
result
source("~/Documents/GitHub/SSSKAT/R/helper.R", echo=TRUE)
# Parameter estimation under the null
para_est <- ssl_theta(Y = Y, X = X, S = S, Z = Z,
id.t = id.t, weights = NULL, full_eval = TRUE, NULL_nlog_like, nit, distri)
para_est
setwd("/Users/tianyuan/Documents/GitHub/SSSKAT")
roxygen2::roxygenise()
